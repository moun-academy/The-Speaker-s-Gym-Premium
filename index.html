<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="theme-color" content="#facc15">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Speaker's Gym">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <title>The Speaker's Gym - MOUN Academy</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: #e5e7eb;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      background: rgba(17, 24, 39, 0.95);
      border-radius: 24px;
      padding: 28px;
      max-width: 720px;
      margin: 0 auto;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(250, 204, 21, 0.2);
    }

    .header { text-align: center; margin-bottom: 24px; }

    h1 {
      font-size: 28px;
      background: linear-gradient(135deg, #facc15, #fbbf24);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 800;
      margin-bottom: 4px;
    }

    .brand {
      font-size: 13px;
      color: #9ca3af;
      letter-spacing: 0.05em;
      margin-bottom: 6px;
    }

    .brand-name {
      color: #ffffff;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 20px rgba(250, 204, 21, 0.3);
    }

    /* Week Calendar */
    .week-calendar {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 20px;
      padding: 12px;
      background: rgba(30, 41, 59, 0.5);
      border-radius: 12px;
    }

    .day-dot {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .day-label { font-size: 10px; color: #6b7280; text-transform: uppercase; }

    .day-circle {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #1f2937;
      border: 2px solid #374151;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .day-circle.completed {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      border-color: #22c55e;
    }

    .day-circle.today { border-color: #facc15; box-shadow: 0 0 0 2px rgba(250, 204, 21, 0.3); }

    /* Stats */
    .stats-bar {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }

    .stat { text-align: center; }
    .stat-value { font-size: 22px; font-weight: bold; color: #facc15; }
    .stat-label { font-size: 10px; color: #9ca3af; text-transform: uppercase; }

    /* Word Box */
    .word-box {
      background: linear-gradient(135deg, #020617, #0f172a);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 16px;
      border: 1px solid #1f2937;
      text-align: center;
    }

    .word-box.active { border-color: rgba(250, 204, 21, 0.5); }

    .label { font-size: 11px; text-transform: uppercase; letter-spacing: 0.1em; color: #6b7280; margin-bottom: 6px; }

    .word {
      font-size: 36px;
      font-weight: 800;
      background: linear-gradient(135deg, #facc15, #fbbf24);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 8px;
    }

    .definition { font-size: 14px; color: #d1d5db; }

    /* Mode Selector */
    .mode-selector {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 16px;
    }

    .mode-btn {
      padding: 10px 16px;
      border-radius: 8px;
      border: 2px solid #374151;
      background: #1f2937;
      color: #d1d5db;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }

    .mode-btn:hover { border-color: #facc15; }
    .mode-btn.active { background: linear-gradient(135deg, #facc15, #fbbf24); color: #0f172a; border-color: #facc15; }

    /* Timer */
    .timer-section {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      margin-bottom: 20px;
    }

    .timer-circle {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 32px;
      font-weight: bold;
      color: #0f172a;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      transition: all 0.3s;
    }

    .timer-circle.warning { background: linear-gradient(135deg, #f97316, #ea580c); }
    .timer-circle.danger { background: linear-gradient(135deg, #ef4444, #dc2626); animation: pulse 1s infinite; }

    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }

    .timer-legend { font-size: 12px; color: #9ca3af; margin-top: 8px; }

    /* Camera Section */
    .camera-section { display: none; margin-bottom: 20px; }
    .camera-section.active { display: block; }

    .video-container {
      position: relative;
      max-width: 100%;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
    }

    #videoElement { 
      width: 100%; 
      height: auto;
      display: block; 
      transform: scaleX(-1); 
    }

    .video-timer {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 20px;
      border-radius: 20px;
      font-size: 20px;
      font-weight: bold;
      display: none;
    }

    .video-timer .rec { width: 10px; height: 10px; background: #ef4444; border-radius: 50%; display: inline-block; margin-right: 8px; animation: pulse 1s infinite; }

    /* Audio Section */
    .audio-section { display: none; margin-bottom: 20px; text-align: center; }
    .audio-section.active { display: block; }

    .audio-visualizer {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      margin: 0 auto 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
    }

    .audio-visualizer.recording { animation: pulse 1s infinite; box-shadow: 0 0 40px rgba(59, 130, 246, 0.5); }

    /* Controls */
    .controls {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .controls button {
      min-width: 140px;
    }

    button {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 12px 16px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    button:hover { transform: translateY(-2px); }
    button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    button.primary { background: linear-gradient(135deg, #facc15, #fbbf24); color: #0f172a; }
    button.secondary { background: linear-gradient(135deg, #374151, #4b5563); }
    button.danger { background: linear-gradient(135deg, #ef4444, #dc2626); }

    /* Rating Modal */
    .rating-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }

    .rating-modal.show { display: flex; }

    .rating-content {
      background: #1f2937;
      border-radius: 20px;
      padding: 32px;
      text-align: center;
      max-width: 360px;
      width: 90%;
    }

    .rating-title { font-size: 20px; font-weight: 700; margin-bottom: 8px; }
    .rating-subtitle { font-size: 14px; color: #9ca3af; margin-bottom: 20px; }

    .rating-stars {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 20px;
    }

    .star {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: #374151;
      border: none;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .star:hover, .star.selected { background: #facc15; transform: scale(1.1); }

    /* Nudge Banner */
    .nudge-banner {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(34, 197, 94, 0.05));
      border: 1px solid rgba(34, 197, 94, 0.3);
      border-radius: 10px;
      padding: 12px 16px;
      margin-bottom: 16px;
      text-align: center;
      font-size: 14px;
      color: #a7f3d0;
      display: none;
    }

    .nudge-banner.show { display: block; }

    /* Download Section */
    .download-section {
      display: none;
      padding: 12px;
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.3);
      border-radius: 10px;
      text-align: center;
      margin-top: 12px;
    }

    .download-section.show { display: block; }
    .download-link { color: #22c55e; font-weight: 600; }

    .transcript-input {
      width: 100%;
      min-height: 90px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #374151;
      background: #0f172a;
      color: #e5e7eb;
      font-size: 14px;
      resize: vertical;
      margin-bottom: 10px;
    }

    /* Share Button */
    .share-btn {
      width: 100%;
      margin-top: 12px;
      background: linear-gradient(135deg, #8b5cf6, #7c3aed);
    }

    /* Achievement Toast */
    .achievement {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #facc15, #fbbf24);
      color: #0f172a;
      padding: 14px 20px;
      border-radius: 12px;
      font-weight: 600;
      box-shadow: 0 10px 30px rgba(250, 204, 21, 0.4);
      transform: translateX(400px);
      transition: transform 0.4s ease;
      z-index: 1000;
    }

    .achievement.show { transform: translateX(0); }

    /* Unlocks Section */
    .unlocks-bar {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .unlock-badge {
      font-size: 11px;
      padding: 6px 12px;
      border-radius: 20px;
      background: #1f2937;
      color: #6b7280;
      border: 1px solid #374151;
    }

    .unlock-badge.unlocked {
      background: linear-gradient(135deg, rgba(250, 204, 21, 0.2), rgba(250, 204, 21, 0.1));
      color: #facc15;
      border-color: rgba(250, 204, 21, 0.3);
    }

    /* Structure Guide */
    .structure-box {
      display: none;
      background: linear-gradient(135deg, #1e293b, #334155);
      border-radius: 14px;
      padding: 20px;
      margin-bottom: 16px;
      border: 1px solid #475569;
    }

    .formula-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .formula-btn {
      flex: 1;
      min-width: 100px;
      padding: 10px 14px;
      border-radius: 8px;
      border: 2px solid #374151;
      background: #1f2937;
      color: #d1d5db;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }

    .formula-btn:hover { border-color: #facc15; }
    .formula-btn.active { background: linear-gradient(135deg, #facc15, #fbbf24); color: #0f172a; border-color: #facc15; }

    .structure-content { color: #e2e8f0; line-height: 1.7; font-size: 14px; }

    .structure-section {
      background: rgba(15, 23, 42, 0.5);
      border-left: 3px solid #facc15;
      padding: 14px;
      margin-bottom: 12px;
      border-radius: 8px;
    }

    .structure-section h4 {
      color: #facc15;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 10px;
    }

    .structure-section strong { color: #fbbf24; display: block; margin: 6px 0; }
    .structure-section em { color: #94a3b8; font-style: normal; display: block; margin-left: 12px; font-size: 13px; }

    .example-box {
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.3);
      border-radius: 6px;
      padding: 10px;
      margin: 8px 0;
      font-style: italic;
      color: #a7f3d0;
      font-size: 13px;
    }

    /* Recording buttons */
    .record-controls {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 20px;
    }

    .record-btn {
      padding: 16px 32px;
      font-size: 16px;
      font-weight: 700;
      border-radius: 50px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .record-btn.start {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      box-shadow: 0 4px 20px rgba(239, 68, 68, 0.4);
      animation: recordPulse 2s infinite;
    }

    .record-btn.stop {
      background: linear-gradient(135deg, #6b7280, #4b5563);
    }

    @keyframes recordPulse {
      0%, 100% { box-shadow: 0 4px 20px rgba(239, 68, 68, 0.4); }
      50% { box-shadow: 0 4px 30px rgba(239, 68, 68, 0.6); }
    }

    .rec-dot {
      width: 12px;
      height: 12px;
      background: white;
      border-radius: 50%;
    }

    .record-btn.start:hover {
      transform: translateY(-2px) scale(1.02);
    }

    /* AI Feedback */
    .ai-panel {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(250, 204, 21, 0.2);
      border-radius: 12px;
      padding: 14px;
      margin: 16px 0;
    }

    .ai-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .ai-panel h3 {
      font-size: 16px;
      margin: 0;
      color: #facc15;
    }

    .ai-toggle {
      position: relative;
      width: 50px;
      height: 26px;
      display: inline-block;
    }

    .ai-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .ai-panel .helper {
      font-size: 12px;
      color: #9ca3af;
      margin-bottom: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .cost-note {
      font-size: 11px;
      color: #6b7280;
      font-style: italic;
    }

    .ai-panel .field-row { display: flex; gap: 8px; margin-bottom: 10px; }
    .ai-panel input { flex: 1; padding: 10px 12px; border-radius: 8px; border: 1px solid #374151; background: #0f172a; color: #e5e7eb; }
    .ai-panel button { padding: 10px 12px; border-radius: 8px; border: none; background: linear-gradient(135deg, #22c55e, #16a34a); color: #0f172a; font-weight: 700; cursor: pointer; }

    .ai-status { font-size: 13px; color: #9ca3af; margin-bottom: 8px; }
    .ai-status.error { color: #f87171; }

    .ai-feedback-box { background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 10px; padding: 12px; color: #e2e8f0; font-size: 14px; white-space: pre-wrap; }

    /* Notification Settings */
    .notification-settings {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(250, 204, 21, 0.2);
      border-radius: 12px;
      padding: 16px;
      margin-top: 20px;
    }

    .notification-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .notification-header h3 {
      font-size: 16px;
      color: #facc15;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .notification-toggle {
      position: relative;
      width: 50px;
      height: 26px;
    }

    .notification-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #374151;
      transition: 0.3s;
      border-radius: 26px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .notification-toggle input:checked + .toggle-slider {
      background: linear-gradient(135deg, #22c55e, #16a34a);
    }

    .notification-toggle input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }

    .notification-time-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 12px;
    }

    .notification-time-row label {
      font-size: 14px;
      color: #9ca3af;
    }

    .notification-time-row input[type="time"] {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #374151;
      background: #0f172a;
      color: #e5e7eb;
      font-size: 14px;
    }

    .notification-status {
      font-size: 12px;
      color: #6b7280;
      margin-top: 10px;
    }

    .notification-status.active {
      color: #22c55e;
    }

    .notification-status.denied {
      color: #ef4444;
    }

    /* App Version Footer */
    .app-version {
      text-align: center;
      padding: 16px 0 0 0;
      margin-top: 20px;
      border-top: 1px solid rgba(55, 65, 81, 0.5);
      font-size: 11px;
      color: #6b7280;
    }

    /* Firebase Auth & Sync */
    .firebase-auth {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(250, 204, 21, 0.2);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
      text-align: center;
    }

    .firebase-auth h3 {
      font-size: 16px;
      color: #facc15;
      margin-bottom: 12px;
    }

    .firebase-auth .helper {
      font-size: 12px;
      color: #9ca3af;
      margin-bottom: 12px;
    }

    .auth-button {
      padding: 12px 24px;
      border-radius: 8px;
      border: none;
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
    }

    .auth-button:hover {
      transform: translateY(-2px);
    }

    .auth-button.google {
      background: white;
      color: #1f2937;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .user-info {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: rgba(15, 23, 42, 0.6);
      border-radius: 8px;
      margin-bottom: 12px;
    }

    .user-email {
      font-size: 13px;
      color: #e2e8f0;
    }

    .sign-out-btn {
      padding: 6px 12px;
      font-size: 12px;
      border-radius: 6px;
      border: none;
      background: rgba(239, 68, 68, 0.2);
      color: #f87171;
      cursor: pointer;
      transition: all 0.2s;
    }

    .sign-out-btn:hover {
      background: rgba(239, 68, 68, 0.3);
    }

    .sync-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: #9ca3af;
      padding: 6px 12px;
      border-radius: 6px;
      background: rgba(15, 23, 42, 0.6);
    }

    .sync-status.syncing {
      color: #60a5fa;
    }

    .sync-status.synced {
      color: #22c55e;
    }

    .sync-status.offline {
      color: #f59e0b;
    }

    .sync-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    @media (max-width: 640px) {
      .container { padding: 20px; }
      h1 { font-size: 24px; }
      .word { font-size: 28px; }
      .controls { grid-template-columns: 1fr; }
      .stats-bar { grid-template-columns: repeat(2, 1fr); }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>üèãÔ∏è The Speaker's Gym</h1>
      <div class="brand">by <span class="brand-name">MOUN Academy</span></div>
    </div>

    <!-- Firebase Auth & Sync -->
    <div class="firebase-auth" id="firebaseAuth">
      <div id="authSignedOut">
        <h3>‚òÅÔ∏è Cloud Sync</h3>
        <div class="helper">Sign in to sync your speeches and stats across all devices</div>
        <button id="googleSignInBtn" class="auth-button google">
          <svg width="18" height="18" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
            <path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"/>
            <path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"/>
            <path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"/>
            <path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"/>
            <path fill="none" d="M0 0h48v48H0z"/>
          </svg>
          Sign in with Google
        </button>
      </div>
      <div id="authSignedIn" style="display: none;">
        <div class="user-info">
          <div>
            <div class="user-email" id="userEmail">user@example.com</div>
            <div class="sync-status" id="syncStatus">
              <span class="sync-dot"></span>
              <span id="syncStatusText">Synced</span>
            </div>
          </div>
          <button id="signOutBtn" class="sign-out-btn">Sign Out</button>
        </div>
        <div class="helper">Your data is securely synced across all devices</div>
      </div>
    </div>

    <!-- Week Calendar -->
    <div class="week-calendar" id="weekCalendar"></div>

    <!-- Stats -->
    <div class="stats-bar">
      <div class="stat">
        <span class="stat-value" id="speechCount">0</span>
        <span class="stat-label">Today</span>
      </div>
      <div class="stat">
        <span class="stat-value" id="streak">0</span>
        <span class="stat-label">Streak üî•</span>
      </div>
      <div class="stat">
        <span class="stat-value" id="avgRating">-</span>
        <span class="stat-label">Avg Feel</span>
      </div>
      <div class="stat">
        <span class="stat-value" id="totalSpeeches">0</span>
        <span class="stat-label">All Time</span>
      </div>
    </div>

    <!-- Nudge Banner -->
    <div class="nudge-banner" id="nudgeBanner"></div>

    <!-- Word Box -->
    <div class="word-box" id="wordBox">
      <div class="label">Your Word</div>
      <div id="word" class="word">Ready?</div>
      <div class="definition" id="definition">Click "New Word" to get started</div>
    </div>

    <!-- Mode Selector -->
    <div class="mode-selector">
      <button class="mode-btn active" id="timerOnlyBtn">‚è±Ô∏è Timer</button>
      <button class="mode-btn" id="audioBtn">üéôÔ∏è Audio</button>
      <button class="mode-btn" id="cameraBtn">üìπ Video</button>
    </div>

    <!-- Timer Section -->
    <div class="timer-section" id="timerSection">
      <div id="timerCircle" class="timer-circle">0:00</div>
      <div class="timer-legend">üü¢ 0-1min | üü† 1-1.5min | üî¥ 1.5-2.5min</div>
      <div class="record-controls">
        <button id="startTimerBtn" class="record-btn start"><span class="rec-dot"></span> Start Speaking</button>
        <button id="stopTimerBtn" class="record-btn stop" style="display: none;">‚èπ Stop</button>
      </div>
    </div>

    <!-- Audio Section -->
    <div class="audio-section" id="audioSection">
      <div class="audio-visualizer" id="audioVisualizer">üéôÔ∏è</div>
      <div id="audioTimer" style="font-size: 28px; font-weight: bold;">0:00</div>
      <div class="timer-legend">Audio recording ‚Ä¢ 2.5 min max</div>
      <div class="record-controls">
        <button id="startAudioBtn" class="record-btn start"><span class="rec-dot"></span> Start Recording</button>
        <button id="stopAudioBtn" class="record-btn stop" style="display: none;">‚èπ Stop Recording</button>
      </div>
      <div class="download-section" id="audioDownload">
        <p style="color: #22c55e; margin-bottom: 8px;">‚úÖ Recording saved!</p>
        <a href="#" id="audioDownloadLink" class="download-link" download="speech.webm">Download Recording</a>
      </div>
    </div>

    <!-- Camera Section -->
    <div class="camera-section" id="cameraSection">
      <div class="video-container">
        <video id="videoElement" autoplay muted playsinline></video>
        <div class="video-timer" id="videoTimer"><span class="rec"></span><span id="videoTimerDisplay">0:00</span></div>
      </div>
      <div class="record-controls">
        <button id="startVideoBtn" class="record-btn start"><span class="rec-dot"></span> Start Recording</button>
        <button id="stopVideoBtn" class="record-btn stop" style="display: none;">‚èπ Stop Recording</button>
      </div>
      <div class="download-section" id="videoDownload">
        <p style="color: #22c55e; margin-bottom: 8px;">‚úÖ Recording saved!</p>
        <a href="#" id="videoDownloadLink" class="download-link" download="speech.webm">Download Recording</a>
      </div>
    </div>

    <!-- Controls -->
    <div class="controls">
      <button id="newWordBtn" class="primary">New Word</button>
      <button id="resetBtn" class="secondary">Reset</button>
    </div>

    <!-- AI Feedback -->
    <div class="ai-panel">
      <div class="ai-header">
        <h3>ü§ñ AI Speech Analysis</h3>
        <label class="ai-toggle">
          <input type="checkbox" id="aiToggle" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="helper">
        <span id="aiToggleHelper">Whisper transcription + GPT-4o analysis with speech metrics (pace, pauses, filler words).</span>
        <span class="cost-note">~$0.02-0.04 per 2-min speech</span>
      </div>
      <textarea id="manualTranscript" class="transcript-input" placeholder="Transcript will appear here automatically after recording. You can also paste text for manual analysis."></textarea>
      <div class="ai-status" id="aiStatus">Waiting for your next recording.</div>
      <div class="ai-feedback-box" id="aiFeedback">Your detailed feedback with speech metrics will appear here.</div>
    </div>

    <!-- Structure Guide -->
    <div style="text-align: center; margin-bottom: 12px;">
      <button id="toggleStructureBtn" class="secondary" style="width: auto;">Show Structure Guide</button>
    </div>

    <div id="structureBox" class="structure-box">
      <h3 style="font-size: 18px; color: #facc15; margin-bottom: 16px; text-align: center;">Your Speaking Roadmap</h3>

      <div class="formula-selector">
        <button class="formula-btn active" data-formula="one-thing">One Thing</button>
        <button class="formula-btn" data-formula="two-types">Two Types</button>
        <button class="formula-btn" data-formula="three-steps">Three Steps</button>
      </div>

      <div class="structure-content" id="structureContent">
        Generate a word first to see your personalized speaking structure
      </div>
    </div>

    <!-- Daily Reminder Notifications -->
    <div class="notification-settings">
      <div class="notification-header">
        <h3>Daily Reminder</h3>
        <label class="notification-toggle">
          <input type="checkbox" id="notificationToggle">
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="notification-time-row">
        <label for="notificationTime">Remind me at:</label>
        <input type="time" id="notificationTime" value="09:00">
      </div>
      <div class="notification-status" id="notificationStatus">
        Enable notifications to get daily practice reminders
      </div>
    </div>

    <!-- App Version -->
    <div class="app-version" id="appVersion">
      Last updated: Loading...
    </div>
  </div>

  <!-- Rating Modal -->
  <div class="rating-modal" id="ratingModal">
    <div class="rating-content">
      <div class="rating-title">How did that feel?</div>
      <div class="rating-subtitle">Rate your confidence (1-5)</div>
      <div class="rating-stars">
        <button class="star" data-rating="1">1</button>
        <button class="star" data-rating="2">2</button>
        <button class="star" data-rating="3">3</button>
        <button class="star" data-rating="4">4</button>
        <button class="star" data-rating="5">5</button>
      </div>
      <button id="skipRating" class="secondary" style="width: 100%;">Skip</button>
    </div>
  </div>

  <!-- Achievement Toast -->
  <div class="achievement" id="achievement"></div>

  <script>
    // Word database
    const words = [
      { word: "Dream", definition: "A cherished aspiration or ideal" },
      { word: "Focus", definition: "The center of interest or activity" },
      { word: "Habit", definition: "A regular tendency or practice" },
      { word: "Growth", definition: "The process of developing" },
      { word: "Change", definition: "To make or become different" },
      { word: "Kindness", definition: "Being friendly and considerate" },
      { word: "Patience", definition: "Accepting delay without anger" },
      { word: "Courage", definition: "Ability to face fear" },
      { word: "Trust", definition: "Firm belief in reliability" },
      { word: "Success", definition: "Accomplishment of an aim" },
      { word: "Confidence", definition: "Feeling of self-assurance" },
      { word: "Leadership", definition: "Action of leading a group" },
      { word: "Goal", definition: "Object of ambition" },
      { word: "Story", definition: "Account of events" },
      { word: "Connection", definition: "Relationship between people" },
      { word: "Challenge", definition: "Something that tests abilities" },
      { word: "Learning", definition: "Acquiring knowledge or skills" },
      { word: "Opportunity", definition: "Favorable situation" },
      { word: "Choice", definition: "Selecting between alternatives" },
      { word: "Action", definition: "Process of doing something" },
      { word: "Fear", definition: "Emotion caused by threat" },
      { word: "Joy", definition: "Feeling of great happiness" },
      { word: "Peace", definition: "Freedom from disturbance" },
      { word: "Purpose", definition: "Reason for existence" },
      { word: "Energy", definition: "Strength for activity" },
      { word: "Motivation", definition: "Reason for acting" },
      { word: "Momentum", definition: "Force of movement" },
      { word: "Passion", definition: "Strong emotion" },
      { word: "Balance", definition: "State of equilibrium" },
      { word: "Vision", definition: "Ability to imagine the future" },
      { word: "Failure", definition: "Lack of success" },
      { word: "Risk", definition: "Possibility of loss or danger" },
      { word: "Gratitude", definition: "Being thankful" },
      { word: "Honesty", definition: "Quality of being truthful" },
      { word: "Respect", definition: "Admiration for someone" },
      { word: "Creativity", definition: "Use of imagination" },
      { word: "Discipline", definition: "Training to follow rules" },
      { word: "Freedom", definition: "State of being free" },
      { word: "Loyalty", definition: "Strong support or allegiance" },
      { word: "Wisdom", definition: "Quality of having experience" },
      { word: "Ambition", definition: "Strong desire to achieve" },
      { word: "Persistence", definition: "Continuing despite difficulty" },
      { word: "Empathy", definition: "Understanding others' feelings" },
      { word: "Curiosity", definition: "Desire to learn or know" },
      { word: "Simplicity", definition: "Quality of being easy" },
      { word: "Silence", definition: "Complete absence of sound" },
      { word: "Time", definition: "Ongoing sequence of events" },
      { word: "Money", definition: "Medium of exchange" },
      { word: "Health", definition: "State of being well" },
      { word: "Family", definition: "Group of related people" }
    ];

    // Structure templates
    function getStructure(word, formula) {
      const structures = {
        'one-thing': `
          <div class="structure-section">
            <h4>1. POINT (10-15 seconds)</h4>
            <strong>"The one thing about ${word.toLowerCase()} is..."</strong>
            <div class="example-box">
              ‚Ä¢ "The one thing about ${word.toLowerCase()} is that it's not what you think..."<br>
              ‚Ä¢ "The one thing about ${word.toLowerCase()} is that everyone gets it wrong..."
            </div>
          </div>
          <div class="structure-section">
            <h4>2. STORY (60-90 seconds)</h4>
            <strong>Prove it with a personal moment:</strong>
            <em>‚Üí Set the scene: "I was... / Last week..."</em>
            <em>‚Üí The conflict: "But then... / The problem was..."</em>
            <em>‚Üí The resolution: "So I... / That's when..."</em>
          </div>
          <div class="structure-section">
            <h4>3. TAKEAWAY (10-15 seconds)</h4>
            <strong>What should they remember?</strong>
            <em>‚Üí "So remember, ${word.toLowerCase()} is..."</em>
            <em>‚Üí "The next time you think about ${word.toLowerCase()}..."</em>
          </div>
        `,
        'two-types': `
          <div class="structure-section">
            <h4>1. POINT (10-15 seconds)</h4>
            <strong>"There are two types of ${word.toLowerCase()}..."</strong>
            <div class="example-box">
              ‚Ä¢ "There are two types of ${word.toLowerCase()} - the kind that helps and the kind that hurts..."<br>
              ‚Ä¢ "There are two ways to think about ${word.toLowerCase()}..."
            </div>
          </div>
          <div class="structure-section">
            <h4>2. CONTRAST (60-90 seconds)</h4>
            <strong>Show both types:</strong>
            <em>‚Üí Type 1: "The first type... For example..."</em>
            <em>‚Üí Type 2: "But the second type... In contrast..."</em>
            <em>‚Üí The insight: "The difference is..."</em>
          </div>
          <div class="structure-section">
            <h4>3. TAKEAWAY (10-15 seconds)</h4>
            <strong>Which type should they choose?</strong>
            <em>‚Üí "The question is: which type are you?"</em>
            <em>‚Üí "Choose the right type of ${word.toLowerCase()}, and..."</em>
          </div>
        `,
        'three-steps': `
          <div class="structure-section">
            <h4>1. POINT (10-15 seconds)</h4>
            <strong>"There are three steps to ${word.toLowerCase()}..."</strong>
            <div class="example-box">
              ‚Ä¢ "If you want real ${word.toLowerCase()}, follow these three steps..."<br>
              ‚Ä¢ "I learned three steps to ${word.toLowerCase()} the hard way..."
            </div>
          </div>
          <div class="structure-section">
            <h4>2. THE STEPS (60-90 seconds)</h4>
            <strong>Walk through each:</strong>
            <em>‚Üí "First, you must... This is crucial because..."</em>
            <em>‚Üí "Second, you need to... Without this..."</em>
            <em>‚Üí "Finally, you have to... This brings it together..."</em>
          </div>
          <div class="structure-section">
            <h4>3. TAKEAWAY (10-15 seconds)</h4>
            <strong>Why these steps matter:</strong>
            <em>‚Üí "Follow these three steps, and ${word.toLowerCase()} becomes..."</em>
            <em>‚Üí "Three steps - that's all it takes."</em>
          </div>
        `
      };
      return structures[formula];
    }

    // Version
    const APP_VERSION = '2025-01-10T22:30:00Z'; // Auto-updated on deployment

    // State
    let stats = JSON.parse(localStorage.getItem('sgStats')) || {
      todaySpeeches: 0, totalSpeeches: 0, streak: 0, ratings: [], weekHistory: {}, lastDate: null
    };

    let currentMode = 'timer';
    let currentFormula = 'one-thing';
    let currentWord = null;
    let timerInterval = null;
    let elapsedSeconds = 0;
    let isRunning = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let stream = null;
    let isRequestingFeedback = false;
    let recognition = null;
    let recognitionActive = false;
    let liveTranscript = '';
    let currentAudioBlob = null;

    // AI Feedback Settings
    let aiEnabled = localStorage.getItem('aiEnabled') !== 'false'; // Default ON

    // Elements
    const wordEl = document.getElementById('word');
    const definitionEl = document.getElementById('definition');
    const wordBox = document.getElementById('wordBox');
    const timerCircle = document.getElementById('timerCircle');
    const structureBox = document.getElementById('structureBox');
    const structureContent = document.getElementById('structureContent');
    const nudgeBanner = document.getElementById('nudgeBanner');
    const achievement = document.getElementById('achievement');
    const ratingModal = document.getElementById('ratingModal');
    const aiFeedback = document.getElementById('aiFeedback');
    const aiStatus = document.getElementById('aiStatus');
    const manualTranscript = document.getElementById('manualTranscript');

    // Initialize
    function init() {
      checkNewDay();
      updateStats();
      updateWeekCalendar();
      updateNudge();
      initSpeechRecognition();
      initAIToggle();
      setAiStatus('Waiting for your next recording.');
      manualTranscript.value = '';
      updateVersionDisplay();
    }

    function initAIToggle() {
      const toggle = document.getElementById('aiToggle');
      const helper = document.getElementById('aiToggleHelper');

      // Set initial state
      toggle.checked = aiEnabled;
      updateAIToggleUI();

      // Handle toggle changes
      toggle.addEventListener('change', () => {
        aiEnabled = toggle.checked;
        localStorage.setItem('aiEnabled', aiEnabled);
        updateAIToggleUI();

        if (aiEnabled) {
          showAchievement('‚ú® AI feedback enabled');
        } else {
          showAchievement('üíæ AI feedback disabled - transcription only');
        }
      });
    }

    function updateAIToggleUI() {
      const helper = document.getElementById('aiToggleHelper');
      if (aiEnabled) {
        helper.textContent = 'Whisper transcription + GPT-4o analysis with speech metrics (pace, pauses, filler words).';
        setAiStatus('AI feedback enabled. Ready for your next recording.');
      } else {
        helper.textContent = 'Transcription only (no AI analysis). Save costs by disabling feedback.';
        setAiStatus('AI feedback disabled. Will show transcript only.');
      }
    }

    function updateVersionDisplay() {
      const versionEl = document.getElementById('appVersion');
      try {
        const date = new Date(APP_VERSION);
        const formatted = date.toLocaleString('en-US', {
          month: '2-digit',
          day: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          hour12: false
        });
        versionEl.textContent = `Last updated: ${formatted}`;
      } catch (e) {
        versionEl.textContent = `Version: ${APP_VERSION}`;
      }
    }

    function checkNewDay() {
      const today = new Date().toDateString();
      if (stats.lastDate !== today) {
        if (stats.lastDate) {
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);
          if (stats.lastDate === yesterday.toDateString() && stats.todaySpeeches > 0) stats.streak++;
          else if (stats.todaySpeeches === 0) stats.streak = 0;
        }
        stats.todaySpeeches = 0;
        stats.lastDate = today;
        saveStats();
      }
    }

    function saveStats() { localStorage.setItem('sgStats', JSON.stringify(stats)); }

    function updateStats() {
      document.getElementById('speechCount').textContent = stats.todaySpeeches;
      document.getElementById('streak').textContent = stats.streak;
      document.getElementById('totalSpeeches').textContent = stats.totalSpeeches;
      const avg = stats.ratings.length ? (stats.ratings.reduce((a,b) => a+b, 0) / stats.ratings.length).toFixed(1) : '-';
      document.getElementById('avgRating').textContent = avg;
    }

    function updateWeekCalendar() {
      const cal = document.getElementById('weekCalendar');
      cal.innerHTML = '';
      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      const today = new Date();
      for (let i = 6; i >= 0; i--) {
        const d = new Date(today);
        d.setDate(d.getDate() - i);
        const key = d.toDateString();
        const isToday = i === 0;
        const completed = stats.weekHistory[key] || (isToday && stats.todaySpeeches > 0);
        cal.innerHTML += `
          <div class="day-dot">
            <span class="day-label">${days[d.getDay()]}</span>
            <div class="day-circle ${completed ? 'completed' : ''} ${isToday ? 'today' : ''}">${completed ? '‚úì' : d.getDate()}</div>
          </div>`;
      }
    }

    function updateNudge() {
      if (stats.todaySpeeches === 0) { nudgeBanner.textContent = "üéØ Complete your first speech today!"; nudgeBanner.classList.add('show'); }
      else if (stats.todaySpeeches === 2) { nudgeBanner.textContent = "üî• One more to hit 3 today!"; nudgeBanner.classList.add('show'); }
      else nudgeBanner.classList.remove('show');
    }

    function showAchievement(text) {
      achievement.textContent = text;
      achievement.classList.add('show');
      setTimeout(() => achievement.classList.remove('show'), 3000);
    }

    function formatTime(sec) { return Math.floor(sec / 60) + ':' + String(sec % 60).padStart(2, '0'); }

    function updateStructure() {
      if (currentWord) structureContent.innerHTML = getStructure(currentWord.word, currentFormula);
    }

    function newWord() {
      reset();
      currentWord = words[Math.floor(Math.random() * words.length)];
      wordEl.textContent = currentWord.word;
      definitionEl.textContent = currentWord.definition;
      updateStructure();
      structureBox.style.display = 'none';
      document.getElementById('toggleStructureBtn').textContent = 'Show Structure Guide';
    }

    function startTimer() {
      if (!currentWord || isRunning) {
        if (!currentWord) showAchievement("Generate a word first!");
        return;
      }
      isRunning = true;
      wordBox.classList.add('active');
      document.getElementById('startTimerBtn').style.display = 'none';
      document.getElementById('stopTimerBtn').style.display = 'block';
      timerInterval = setInterval(() => {
        elapsedSeconds++;
        updateTimerDisplay();
        if (elapsedSeconds >= 150) stopTimer(true);
      }, 1000);
    }

    function stopTimer(auto = false) {
      clearInterval(timerInterval);
      isRunning = false;
      wordBox.classList.remove('active');
      document.getElementById('startTimerBtn').style.display = 'block';
      document.getElementById('stopTimerBtn').style.display = 'none';
      if (elapsedSeconds >= 30) showRatingModal();
    }

    function reset() {
      clearInterval(timerInterval);
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      isRunning = false;
      elapsedSeconds = 0;
      currentAudioBlob = null;
      updateTimerDisplay();
      wordBox.classList.remove('active');
      timerCircle.classList.remove('warning', 'danger');
      document.getElementById('audioDownload').classList.remove('show');
      document.getElementById('videoDownload').classList.remove('show');
      document.getElementById('audioVisualizer').classList.remove('recording');
      document.getElementById('videoTimer').style.display = 'none';

      // Reset all buttons
      document.getElementById('startTimerBtn').style.display = 'block';
      document.getElementById('stopTimerBtn').style.display = 'none';
      document.getElementById('startAudioBtn').style.display = 'block';
      document.getElementById('stopAudioBtn').style.display = 'none';
      document.getElementById('startVideoBtn').style.display = 'block';
      document.getElementById('stopVideoBtn').style.display = 'none';
    }

    function setAiStatus(text, isError = false) {
      aiStatus.textContent = text;
      aiStatus.classList.toggle('error', isError);
    }

    function initSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        setAiStatus('Live transcription unavailable on this browser. Paste your transcript to get feedback.', true);
        return;
      }

      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';

      recognition.onresult = (event) => {
        let transcript = '';
        for (let i = 0; i < event.results.length; i++) {
          transcript += event.results[i][0].transcript + ' ';
        }
        liveTranscript = transcript.trim();
        manualTranscript.value = liveTranscript;
      };

      recognition.onerror = () => {
        setAiStatus('Live transcription unavailable. Paste your transcript to get feedback.', true);
      };

      recognition.onend = () => {
        recognitionActive = false;
        if (liveTranscript) setAiStatus('Transcript captured. Generating feedback soon.');
      };
    }

    function startTranscriptionCapture() {
      if (!recognition || recognitionActive) return;
      liveTranscript = '';
      try {
        recognition.start();
        recognitionActive = true;
        setAiStatus('Listening and transcribing...');
      } catch (err) {
        console.error('Could not start recognition:', err);
      }
    }

    function stopTranscriptionCapture() {
      if (recognition && recognitionActive) {
        recognition.stop();
      }
    }

    function getTranscriptForFeedback() {
      const text = (manualTranscript.value || liveTranscript || '').trim();
      if (!text) return '';
      const header = currentWord ? `Word prompt: ${currentWord.word}\n` : '';
      const duration = elapsedSeconds ? `Duration: ${formatTime(elapsedSeconds)}\n` : '';
      return `${header}${duration}Transcript: ${text}`.trim();
    }

    async function requestFeedbackWithAudio(audioBlob, duration) {
      if (!audioBlob) {
        setAiStatus('No audio recording available.', true);
        return;
      }

      // If AI is disabled, just show transcript without analysis
      if (!aiEnabled) {
        setAiStatus('Recording saved. AI feedback is disabled (transcript only).');
        aiFeedback.textContent = 'AI feedback is disabled. Toggle it ON above to get detailed speech analysis.\n\nYour recording has been saved and you can download it below.';
        return;
      }

      if (isRequestingFeedback) return;
      isRequestingFeedback = true;
      setAiStatus('Analyzing your speech with AI (transcription + vocal analysis)...');

      try {
        // Create form data with audio file
        const formData = new FormData();
        formData.append('audio', audioBlob, 'speech.webm');
        formData.append('duration', duration.toString());

        const feedbackRes = await fetch('/api/feedback', {
          method: 'POST',
          body: formData
        });

        if (!feedbackRes.ok) throw new Error('Feedback generation failed');
        const feedbackData = await feedbackRes.json();

        const feedbackText = feedbackData.feedback?.trim() || 'No feedback generated.';
        const transcript = feedbackData.transcript || '';
        const metrics = feedbackData.metrics || {};

        // Update UI with transcript
        if (transcript) {
          manualTranscript.value = transcript;
        }

        // Display feedback with metrics
        let displayText = feedbackText;
        if (metrics.wordsPerMinute) {
          displayText = `üìä Speech Metrics:\n` +
            `‚Ä¢ Pace: ${metrics.wordsPerMinute} WPM (${metrics.pacingVariation})\n` +
            `‚Ä¢ Pauses: ${metrics.pauseCount} pauses (avg ${metrics.averagePauseDuration}s)\n` +
            `‚Ä¢ Filler words: ${metrics.fillerWordCount}\n\n` +
            displayText;
        }

        aiFeedback.textContent = displayText;
        setAiStatus('AI analysis complete!');
      } catch (err) {
        console.error(err);
        setAiStatus('Unable to analyze audio. Check console for details.', true);
      } finally {
        isRequestingFeedback = false;
      }
    }

    async function requestFeedback(transcript) {
      // Fallback for manual text input
      const trimmed = (transcript || '').trim();
      if (!trimmed) { setAiStatus('Add a transcript to get AI feedback.', true); return; }
      if (isRequestingFeedback) return;
      isRequestingFeedback = true;
      setAiStatus('Requesting AI feedback...');

      try {
        const feedbackRes = await fetch('/api/feedback', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text: trimmed })
        });

        if (!feedbackRes.ok) throw new Error('Feedback generation failed');
        const feedbackData = await feedbackRes.json();
        const feedbackText = feedbackData.feedback?.trim() || 'No feedback generated.';

        aiFeedback.textContent = feedbackText;
        setAiStatus('Feedback ready!');
      } catch (err) {
        console.error(err);
        setAiStatus('Unable to fetch feedback right now.', true);
      } finally {
        isRequestingFeedback = false;
      }
    }

    function updateTimerDisplay() {
      const time = formatTime(elapsedSeconds);
      timerCircle.textContent = time;
      document.getElementById('audioTimer').textContent = time;
      document.getElementById('videoTimerDisplay').textContent = time;
      timerCircle.classList.remove('warning', 'danger');
      if (elapsedSeconds >= 90) timerCircle.classList.add('danger');
      else if (elapsedSeconds >= 60) timerCircle.classList.add('warning');
    }

    function showRatingModal() { ratingModal.classList.add('show'); }

    function submitRating(rating) {
      ratingModal.classList.remove('show');
      if (rating) stats.ratings.push(rating);
      completeSpeech();
    }

    function completeSpeech() {
      stats.todaySpeeches++;
      stats.totalSpeeches++;
      stats.weekHistory[new Date().toDateString()] = true;
      saveStats();
      updateStats();
      updateWeekCalendar();
      updateNudge();
      if (stats.todaySpeeches === 1) showAchievement("üéØ First speech of the day!");
      else if (stats.todaySpeeches === 3) showAchievement("üî• 3 speeches! On fire!");
    }

    // Mode switching
    function setMode(mode) {
      currentMode = mode;
      document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
      document.getElementById('timerSection').style.display = 'none';
      document.getElementById('audioSection').classList.remove('active');
      document.getElementById('cameraSection').classList.remove('active');
      stopMedia();

      if (mode === 'timer') {
        document.getElementById('timerOnlyBtn').classList.add('active');
        document.getElementById('timerSection').style.display = 'flex';
      } else if (mode === 'audio') {
        document.getElementById('audioBtn').classList.add('active');
        document.getElementById('audioSection').classList.add('active');
        initAudio();
      } else {
        document.getElementById('cameraBtn').classList.add('active');
        document.getElementById('cameraSection').classList.add('active');
        initCamera();
      }
      reset();
    }

    async function initCamera() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: "user" }, 
          audio: true 
        });
        document.getElementById('videoElement').srcObject = stream;
      } catch (e) { showAchievement("‚ö†Ô∏è Camera access denied"); setMode('timer'); }
    }

    async function initAudio() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (e) { showAchievement("‚ö†Ô∏è Mic access denied"); setMode('timer'); }
    }

    function stopMedia() {
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
    }

    function startAudioRecording() {
      if (!currentWord) { showAchievement("Generate a word first!"); return; }
      recordedChunks = [];
      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        currentAudioBlob = blob;
        document.getElementById('audioDownloadLink').href = URL.createObjectURL(blob);
        document.getElementById('audioDownload').classList.add('show');

        // Send audio to API for Whisper transcription + analysis
        requestFeedbackWithAudio(blob, elapsedSeconds);
      };
      mediaRecorder.start();
      document.getElementById('audioVisualizer').classList.add('recording');
      document.getElementById('startAudioBtn').style.display = 'none';
      document.getElementById('stopAudioBtn').style.display = 'block';
      setAiStatus('Recording audio... Will analyze with AI when done.');
      isRunning = true;
      wordBox.classList.add('active');
      timerInterval = setInterval(() => {
        elapsedSeconds++;
        updateTimerDisplay();
        if (elapsedSeconds >= 150) stopAudioRecording();
      }, 1000);
    }

    function stopAudioRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      clearInterval(timerInterval);
      isRunning = false;
      wordBox.classList.remove('active');
      document.getElementById('audioVisualizer').classList.remove('recording');
      document.getElementById('startAudioBtn').style.display = 'block';
      document.getElementById('stopAudioBtn').style.display = 'none';
      if (elapsedSeconds >= 30) showRatingModal();
    }

    function startVideoRecording() {
      if (!currentWord) { showAchievement("Generate a word first!"); return; }
      recordedChunks = [];
      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        currentAudioBlob = blob;
        document.getElementById('videoDownloadLink').href = URL.createObjectURL(blob);
        document.getElementById('videoDownload').classList.add('show');

        // Send audio track to API for Whisper transcription + analysis
        // Note: We send the whole video blob, backend will extract audio
        requestFeedbackWithAudio(blob, elapsedSeconds);
      };
      mediaRecorder.start();
      document.getElementById('videoTimer').style.display = 'block';
      document.getElementById('startVideoBtn').style.display = 'none';
      document.getElementById('stopVideoBtn').style.display = 'block';
      setAiStatus('Recording video... Will analyze audio with AI when done.');
      isRunning = true;
      wordBox.classList.add('active');
      timerInterval = setInterval(() => {
        elapsedSeconds++;
        updateTimerDisplay();
        if (elapsedSeconds >= 150) stopVideoRecording();
      }, 1000);
    }

    function stopVideoRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      clearInterval(timerInterval);
      isRunning = false;
      wordBox.classList.remove('active');
      document.getElementById('videoTimer').style.display = 'none';
      document.getElementById('startVideoBtn').style.display = 'block';
      document.getElementById('stopVideoBtn').style.display = 'none';
      if (elapsedSeconds >= 30) showRatingModal();
    }

    // Event listeners
    document.getElementById('newWordBtn').addEventListener('click', newWord);
    document.getElementById('resetBtn').addEventListener('click', reset);
    document.getElementById('timerOnlyBtn').addEventListener('click', () => setMode('timer'));
    document.getElementById('audioBtn').addEventListener('click', () => setMode('audio'));
    document.getElementById('cameraBtn').addEventListener('click', () => setMode('video'));
    document.getElementById('skipRating').addEventListener('click', () => submitRating(null));

    document.getElementById('startTimerBtn').addEventListener('click', startTimer);
    document.getElementById('stopTimerBtn').addEventListener('click', () => stopTimer());
    document.getElementById('startAudioBtn').addEventListener('click', startAudioRecording);
    document.getElementById('stopAudioBtn').addEventListener('click', stopAudioRecording);
    document.getElementById('startVideoBtn').addEventListener('click', startVideoRecording);
    document.getElementById('stopVideoBtn').addEventListener('click', stopVideoRecording);

    document.getElementById('toggleStructureBtn').addEventListener('click', () => {
      if (!currentWord) return;
      if (structureBox.style.display === 'none' || structureBox.style.display === '') {
        structureBox.style.display = 'block';
        document.getElementById('toggleStructureBtn').textContent = 'Hide Structure Guide';
      } else {
        structureBox.style.display = 'none';
        document.getElementById('toggleStructureBtn').textContent = 'Show Structure Guide';
      }
    });

    document.querySelectorAll('.formula-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.formula-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentFormula = btn.dataset.formula;
        updateStructure();
      });
    });

    document.querySelectorAll('.star').forEach(star => {
      star.addEventListener('click', () => {
        document.querySelectorAll('.star').forEach(s => s.classList.remove('selected'));
        star.classList.add('selected');
        setTimeout(() => submitRating(parseInt(star.dataset.rating)), 300);
      });
    });

    // ===== NOTIFICATION SYSTEM WITH INDEXEDDB =====
    let notificationSettings = {
      enabled: false,
      time: '09:00',
      lastNotificationDate: null
    };

    const notificationToggle = document.getElementById('notificationToggle');
    const notificationTime = document.getElementById('notificationTime');
    const notificationStatus = document.getElementById('notificationStatus');
    let swRegistration = null;

    // IndexedDB for sharing data with service worker
    function openNotificationDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('SpeakersGymDB', 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains('settings')) {
            db.createObjectStore('settings', { keyPath: 'key' });
          }
          if (!db.objectStoreNames.contains('stats')) {
            db.createObjectStore('stats', { keyPath: 'key' });
          }
        };
      });
    }

    async function saveSettingsToDB(settings) {
      try {
        const db = await openNotificationDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction('settings', 'readwrite');
          const store = tx.objectStore('settings');
          const request = store.put({ key: 'notifications', value: settings });
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      } catch (e) {
        console.error('Error saving to IndexedDB:', e);
      }
    }

    async function loadSettingsFromDB() {
      try {
        const db = await openNotificationDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction('settings', 'readonly');
          const store = tx.objectStore('settings');
          const request = store.get('notifications');
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result?.value);
        });
      } catch (e) {
        console.error('Error loading from IndexedDB:', e);
        return null;
      }
    }

    async function saveStatsToDB() {
      try {
        const db = await openNotificationDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction('stats', 'readwrite');
          const store = tx.objectStore('stats');
          const request = store.put({
            key: 'daily',
            value: {
              todaySpeeches: stats.todaySpeeches,
              lastDate: stats.lastDate
            }
          });
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      } catch (e) {
        console.error('Error saving stats to IndexedDB:', e);
      }
    }

    async function saveNotificationSettings() {
      localStorage.setItem('sgNotifications', JSON.stringify(notificationSettings));
      await saveSettingsToDB(notificationSettings);
    }

    function updateNotificationStatus() {
      if (!('Notification' in window)) {
        notificationStatus.textContent = 'Notifications not supported in this browser';
        notificationStatus.className = 'notification-status denied';
        notificationToggle.disabled = true;
        return;
      }

      if (Notification.permission === 'denied') {
        notificationStatus.textContent = 'Notifications blocked. Enable in browser settings.';
        notificationStatus.className = 'notification-status denied';
        notificationToggle.checked = false;
        notificationSettings.enabled = false;
        saveNotificationSettings();
        return;
      }

      if (notificationSettings.enabled && Notification.permission === 'granted') {
        notificationStatus.textContent = `Reminder set for ${formatTime12h(notificationSettings.time)}`;
        notificationStatus.className = 'notification-status active';
      } else {
        notificationStatus.textContent = 'Enable to get daily practice reminders';
        notificationStatus.className = 'notification-status';
      }
    }

    function formatTime12h(time24) {
      const [hours, minutes] = time24.split(':').map(Number);
      const ampm = hours >= 12 ? 'PM' : 'AM';
      const hours12 = hours % 12 || 12;
      return `${hours12}:${String(minutes).padStart(2, '0')} ${ampm}`;
    }

    async function requestNotificationPermission() {
      if (!('Notification' in window)) return false;
      if (Notification.permission === 'granted') return true;
      if (Notification.permission !== 'denied') {
        const permission = await Notification.requestPermission();
        return permission === 'granted';
      }
      return false;
    }

    // Register for Periodic Background Sync (for scheduled notifications)
    async function registerPeriodicSync() {
      if (!swRegistration) return false;

      try {
        // Check if periodic sync is supported
        if ('periodicSync' in swRegistration) {
          const status = await navigator.permissions.query({ name: 'periodic-background-sync' });
          if (status.state === 'granted') {
            await swRegistration.periodicSync.register('daily-reminder-sync', {
              minInterval: 60 * 60 * 1000 // Check every hour minimum
            });
            console.log('Periodic sync registered');
            return true;
          }
        }
      } catch (e) {
        console.log('Periodic sync not available:', e);
      }

      // Fallback: use regular background sync
      try {
        if ('sync' in swRegistration) {
          await swRegistration.sync.register('daily-reminder');
          console.log('Background sync registered');
          return true;
        }
      } catch (e) {
        console.log('Background sync not available:', e);
      }

      return false;
    }

    // Ask service worker to check and show notification
    function triggerNotificationCheck() {
      if (swRegistration && swRegistration.active) {
        swRegistration.active.postMessage({ type: 'CHECK_REMINDER' });
      }
    }

    async function handleNotificationToggle() {
      if (notificationToggle.checked) {
        const granted = await requestNotificationPermission();
        if (granted) {
          notificationSettings.enabled = true;
          notificationSettings.time = notificationTime.value;
          await saveNotificationSettings();
          await saveStatsToDB();
          await registerPeriodicSync();
          triggerNotificationCheck();
          showAchievement("Daily reminders enabled!");
        } else {
          notificationToggle.checked = false;
          notificationSettings.enabled = false;
          await saveNotificationSettings();
        }
      } else {
        notificationSettings.enabled = false;
        await saveNotificationSettings();
        // Unregister periodic sync
        if (swRegistration && 'periodicSync' in swRegistration) {
          try {
            await swRegistration.periodicSync.unregister('daily-reminder-sync');
          } catch (e) { /* ignore */ }
        }
      }
      updateNotificationStatus();
    }

    async function handleTimeChange() {
      notificationSettings.time = notificationTime.value;
      const today = new Date().toDateString();
      if (notificationSettings.lastNotificationDate === today) {
        const [targetHours, targetMinutes] = notificationSettings.time.split(':').map(Number);
        const now = new Date();
        if (now.getHours() < targetHours ||
            (now.getHours() === targetHours && now.getMinutes() < targetMinutes)) {
          notificationSettings.lastNotificationDate = null;
        }
      }
      await saveNotificationSettings();
      updateNotificationStatus();
    }

    async function initNotifications() {
      // Load from IndexedDB first, then localStorage as fallback
      const dbSettings = await loadSettingsFromDB();
      if (dbSettings) {
        notificationSettings = dbSettings;
      } else {
        const lsSettings = localStorage.getItem('sgNotifications');
        if (lsSettings) {
          notificationSettings = JSON.parse(lsSettings);
          await saveSettingsToDB(notificationSettings);
        }
      }

      notificationToggle.checked = notificationSettings.enabled;
      notificationTime.value = notificationSettings.time;

      notificationToggle.addEventListener('change', handleNotificationToggle);
      notificationTime.addEventListener('change', handleTimeChange);

      updateNotificationStatus();

      // Sync stats to IndexedDB so service worker can access
      await saveStatsToDB();

      // Register periodic sync if notifications enabled
      if (notificationSettings.enabled && Notification.permission === 'granted') {
        await registerPeriodicSync();
        // Check immediately when app opens
        setTimeout(triggerNotificationCheck, 2000);
      }
    }

    // Update IndexedDB when stats change (hook into completeSpeech)
    const originalCompleteSpeech = completeSpeech;
    completeSpeech = function() {
      originalCompleteSpeech();
      saveStatsToDB();
    };

    init();

    // Register Service Worker for PWA
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js')
        .then(async (reg) => {
          console.log('Service Worker registered');
          swRegistration = reg;
          // Wait for service worker to be ready
          await navigator.serviceWorker.ready;
          // Initialize notifications after SW is ready
          await initNotifications();
        })
        .catch(err => {
          console.log('Service Worker registration failed:', err);
          initNotifications();
        });
    } else {
      initNotifications();
    }
  </script>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

  <script>
    // ===== FIREBASE CONFIGURATION =====
    // TODO: Replace with your Firebase project config from Firebase Console
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
      projectId: "YOUR_PROJECT_ID",
      storageBucket: "YOUR_PROJECT_ID.appspot.com",
      messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
      appId: "YOUR_APP_ID"
    };

    // Initialize Firebase
    let app, auth, db, currentUser = null;
    let syncEnabled = false;

    try {
      app = firebase.initializeApp(firebaseConfig);
      auth = firebase.auth();
      db = firebase.firestore();

      // Enable offline persistence
      db.enablePersistence({ synchronizeTabs: true })
        .catch((err) => {
          if (err.code == 'failed-precondition') {
            console.log('Multiple tabs open, persistence can only be enabled in one tab at a time.');
          } else if (err.code == 'unimplemented') {
            console.log('The current browser does not support offline persistence');
          }
        });

      syncEnabled = true;
      console.log('Firebase initialized successfully');
    } catch (error) {
      console.error('Firebase initialization error:', error);
      console.log('App will work offline only. Add Firebase config to enable sync.');
    }

    // ===== FIREBASE SYNC FUNCTIONS =====

    function updateSyncStatus(status, text) {
      const syncStatus = document.getElementById('syncStatus');
      const syncStatusText = document.getElementById('syncStatusText');

      if (syncStatus && syncStatusText) {
        syncStatus.className = `sync-status ${status}`;
        syncStatusText.textContent = text;
      }
    }

    async function syncSpeechToFirebase(speechData) {
      if (!syncEnabled || !currentUser) return;

      try {
        updateSyncStatus('syncing', 'Syncing...');

        await db.collection('users').doc(currentUser.uid)
          .collection('speeches').add({
            ...speechData,
            userId: currentUser.uid,
            syncedAt: firebase.firestore.FieldValue.serverTimestamp()
          });

        updateSyncStatus('synced', 'Synced');
        setTimeout(() => updateSyncStatus('synced', 'Up to date'), 2000);
      } catch (error) {
        console.error('Error syncing speech:', error);
        updateSyncStatus('offline', 'Sync failed');
      }
    }

    async function syncStatsToFirebase(statsData) {
      if (!syncEnabled || !currentUser) return;

      try {
        updateSyncStatus('syncing', 'Syncing...');

        await db.collection('users').doc(currentUser.uid).set({
          stats: statsData,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        updateSyncStatus('synced', 'Synced');
        setTimeout(() => updateSyncStatus('synced', 'Up to date'), 2000);
      } catch (error) {
        console.error('Error syncing stats:', error);
        updateSyncStatus('offline', 'Sync failed');
      }
    }

    async function syncSettingsToFirebase(settings) {
      if (!syncEnabled || !currentUser) return;

      try {
        await db.collection('users').doc(currentUser.uid).set({
          settings: settings,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
      } catch (error) {
        console.error('Error syncing settings:', error);
      }
    }

    async function loadDataFromFirebase() {
      if (!syncEnabled || !currentUser) return;

      try {
        updateSyncStatus('syncing', 'Loading...');

        // Load user stats and settings
        const userDoc = await db.collection('users').doc(currentUser.uid).get();

        if (userDoc.exists) {
          const data = userDoc.data();

          // Merge with local data (prefer remote if different)
          if (data.stats) {
            stats = { ...stats, ...data.stats };
            saveStats();
            updateStats();
            updateWeekCalendar();
            updateNudge();
          }

          if (data.settings) {
            if (data.settings.aiEnabled !== undefined) {
              aiEnabled = data.settings.aiEnabled;
              const toggle = document.getElementById('aiToggle');
              if (toggle) toggle.checked = aiEnabled;
              updateAIToggleUI();
            }

            if (data.settings.notifications) {
              notificationSettings = { ...notificationSettings, ...data.settings.notifications };
              await saveSettingsToDB(notificationSettings);
            }
          }
        }

        updateSyncStatus('synced', 'Up to date');
      } catch (error) {
        console.error('Error loading from Firebase:', error);
        updateSyncStatus('offline', 'Load failed');
      }
    }

    async function migrateLocalDataToFirebase() {
      if (!syncEnabled || !currentUser) return;

      try {
        updateSyncStatus('syncing', 'Migrating data...');

        // Check if migration already done
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        if (userDoc.exists && userDoc.data().migrated) {
          console.log('Data already migrated');
          return;
        }

        // Upload current stats
        await syncStatsToFirebase(stats);

        // Upload settings
        await syncSettingsToFirebase({
          aiEnabled: aiEnabled,
          notifications: notificationSettings
        });

        // Mark as migrated
        await db.collection('users').doc(currentUser.uid).set({
          migrated: true,
          migratedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        console.log('Local data migrated to Firebase');
        showAchievement('üì§ Data synced to cloud!');
        updateSyncStatus('synced', 'Up to date');
      } catch (error) {
        console.error('Migration error:', error);
        updateSyncStatus('offline', 'Migration failed');
      }
    }

    // ===== AUTH STATE MANAGEMENT =====

    if (syncEnabled) {
      auth.onAuthStateChanged(async (user) => {
        const authSignedOut = document.getElementById('authSignedOut');
        const authSignedIn = document.getElementById('authSignedIn');
        const userEmail = document.getElementById('userEmail');

        if (user) {
          // User signed in
          currentUser = user;
          console.log('User signed in:', user.email);

          // Update UI
          if (authSignedOut) authSignedOut.style.display = 'none';
          if (authSignedIn) authSignedIn.style.display = 'block';
          if (userEmail) userEmail.textContent = user.email;

          // Load data from Firebase
          await loadDataFromFirebase();

          // Migrate local data if first time
          await migrateLocalDataToFirebase();

          // Set up real-time sync listener
          db.collection('users').doc(user.uid).onSnapshot((doc) => {
            if (doc.exists) {
              const data = doc.data();
              if (data.stats) {
                stats = { ...stats, ...data.stats };
                saveStats();
                updateStats();
                updateWeekCalendar();
                updateNudge();
              }
            }
          });

        } else {
          // User signed out
          currentUser = null;
          console.log('User signed out');

          // Update UI
          if (authSignedOut) authSignedOut.style.display = 'block';
          if (authSignedIn) authSignedIn.style.display = 'none';
          updateSyncStatus('offline', 'Not syncing');
        }
      });

      // Sign in button
      const googleSignInBtn = document.getElementById('googleSignInBtn');
      if (googleSignInBtn) {
        googleSignInBtn.addEventListener('click', async () => {
          try {
            const provider = new firebase.auth.GoogleAuthProvider();
            await auth.signInWithPopup(provider);
            showAchievement('‚úÖ Signed in successfully!');
          } catch (error) {
            console.error('Sign in error:', error);
            showAchievement('‚ùå Sign in failed: ' + error.message);
          }
        });
      }

      // Sign out button
      const signOutBtn = document.getElementById('signOutBtn');
      if (signOutBtn) {
        signOutBtn.addEventListener('click', async () => {
          try {
            await auth.signOut();
            showAchievement('üëã Signed out');
          } catch (error) {
            console.error('Sign out error:', error);
          }
        });
      }
    }

    // ===== HOOK INTO EXISTING FUNCTIONS FOR AUTO-SYNC =====

    // Wrap completeSpeech to sync to Firebase
    const originalCompleteSpeechFunc = completeSpeech;
    completeSpeech = function() {
      originalCompleteSpeechFunc();

      // Sync to Firebase
      if (syncEnabled && currentUser) {
        syncStatsToFirebase(stats);

        // If there's a recording with transcript/feedback, save it
        const transcript = manualTranscript?.value || '';
        const feedback = aiFeedback?.textContent || '';

        if (transcript || feedback) {
          syncSpeechToFirebase({
            word: currentWord?.word || '',
            definition: currentWord?.definition || '',
            duration: elapsedSeconds,
            transcript: transcript,
            feedback: feedback,
            rating: stats.ratings[stats.ratings.length - 1] || null,
            createdAt: new Date().toISOString(),
            mode: currentMode
          });
        }
      }
    };

    // Wrap saveStats to sync
    const originalSaveStats = saveStats;
    saveStats = function() {
      originalSaveStats();
      if (syncEnabled && currentUser) {
        syncStatsToFirebase(stats);
      }
    };

    // Wrap AI toggle to sync settings
    const originalUpdateAIToggleUI = updateAIToggleUI;
    updateAIToggleUI = function() {
      originalUpdateAIToggleUI();
      if (syncEnabled && currentUser) {
        syncSettingsToFirebase({
          aiEnabled: aiEnabled,
          notifications: notificationSettings
        });
      }
    };

    // Monitor connection status
    if (syncEnabled) {
      window.addEventListener('online', () => {
        updateSyncStatus('synced', 'Back online');
        if (currentUser) {
          loadDataFromFirebase();
        }
      });

      window.addEventListener('offline', () => {
        updateSyncStatus('offline', 'Offline');
      });
    }

  </script>
</body>
</html>
